import streamlit as st
st.title("Monitoring of User Behavior of an eCommerce site")
st.sidebar.title("Table of contents")
pages=["Exploration", "DataVizualization", "Modelling","Results", "Conclusion"]
page=st.sidebar.radio("Go to", pages)

import streamlit as st
import pandas as pd
import numpy as np
import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

base="light"
secondaryBackgroundColor="#f1f6f0"
font="monospace"
event_df = pd.read_csv('events.csv')
category_tree = pd.read_csv('category_tree.csv')
item_properties_part1 = pd.read_csv('item_properties_part1.csv')
item_properties_part2 = pd.read_csv('item_properties_part2.csv')

if page == pages[0] : 
  st.write("### Presentation of data")
  st.dataframe(event_df.head(10))
  st.dataframe(category_tree.head(10))
  st.dataframe(item_properties_part1.head(10))
  st.dataframe(item_properties_part2.head(10))
  st.write("""
    In total, there are 4 datasets available, which were taken from the website: [Kaggle RetailRocket eCommerce Dataset](https://www.kaggle.com/retailrocket/ecommerce-dataset/home) and are allowed to be shared and modified under the license: CC BY-NC-SA 4.0 DEED.
    The item property datasets were used in the Exploratory Analysis for visualizations concerning the price. The category tree dataset was not used as the link between category ID to parent ID did not provide any additional value for the project objective. The main dataset that was used was the events dataset, as it pertained to the user behavior and also provided information about item transactions.

    **Data Frame**
    The dataset “events.csv” comprises 2.7 million rows of data documenting events generated by users. Each row contains the following fields:
    - Event: Denotes the type of event that occurred. Events could include various user interactions.
    - Timestamp: Records the precise date and time when the event occurred. The timestamp provides granularity, allowing analysis of user behavior over time.
    - Visitor ID: Each user or visitor to the platform is assigned a unique identifier. This ID tracks individual user interactions and analyzes their behavior patterns across different events.
    - Item ID: Identifies the specific product or item associated with the event. For instance, if the event is a purchase, the item ID would correspond to the product bought by the user.
    - Transaction ID: Applicable only for events related to transactions, such as purchases. It records a unique identifier for each transaction, facilitating analysis of purchase behavior and revenue generation.
    - Type of Event: Categorizes the event into different types, providing insights into the nature of user interactions.
    - Date of Event: Complements the timestamp by providing the date (without the time component) on which the event occurred.
    - Visitor ID Creating the Event: Similar to the Visitor ID, this field records the unique identifier of the user who initiated the event. It helps understand user engagement and the role of specific users in driving platform activity.
    - Product ID Associated with the Event: Mirrors the Item ID and specifies the product or item involved in the event.
    """)
if page == pages[1] : 
  st.write("### DataVizualization")
  fig=plt.figure()
  sns.countplot(x='event', data=event_df)
  st.pyplot(fig)



if page == pages[2] : 
  st.write("### Modelling")

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn import metrics



if st.sidebar.checkbox("Modelling"):
    st.write("### Modelling")

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import confusion_matrix


option = st.checkbox('Choose a modeling method')

# If checkbox is checked, display the modeling options
if option:
    choice = st.selectbox('Choice of the model', ['Logistic Regression', 'Decision Tree Classifier', 'Random Forest Classifier'])
    st.write('The chosen model is:', choice)

    # Add your modeling code here based on the selected choice
    if choice == 'Logistic Regression':
        # Add code for Logistic Regression
        pass
    elif choice == 'Decision Tree Classifier':
        # Add code for Decision Tree Classifier
        pass
    elif choice == 'Random Forest Classifier':
        # Add code for Random Forest Classifier
        pass
